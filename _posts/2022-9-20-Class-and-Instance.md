---
layout: posts
title: クラスとインスタンス
description: クラス定義とインスタンス生成の基本
date: 2022-9-20 20:52:00 +0900
---
今回からクラスとインスタンスを定義、生成する方法を説明します

## クラス定義とインスタンスの生成

はじめはごく簡単な例から始めます。
クラスはclassキーワードを使って定義します。
また、クラス名には定数（最初の文字が大文字）を使います。

```ruby
class Sample
end

a = Sample.new
b = Sample.new
p a.class
p a.class.ancestors
p a.object_id
p b.object_id
```

- class〜endは`Sample`という名前のクラスを定義している。
このクラスは何も中身がない、最も簡単なクラス。
もちろん、普通は様々な定義をクラスの中に書く。
- クラスには`new`メソッドがあらかじめ定義されている。
newメソッドはそのクラスのインスタンスを生成する。
通常はひとつのクラスから（newを使うたびに）複数のインスタンスを生成できる。
- `class`メソッドをインスタンスに対して実行すると、そのインスタンスのクラスを返す。
`p`はデバッグ用のコマンドで、引数を画面に表示し改行も加える。
- ancestorsはクラスの親クラス、そのまた親クラスとたどっていき、それらの配列を返す。
このときクラスだけでなくモジュールも配列の要素に加える。
クラスには親子関係がある、ということを覚えておいてください。
詳しくは次回以降の記事で説明します
- object\_idメソッドはオブジェクト（インスタンス）に割り振られた番号（ID）を返す。
異なるオブジェクトには異なるIDが与えられる

実行すると次のように表示されます。

```
Sample
[Sample, Object, Kernel, BasicObject]
60
80
```

これから、Sampleクラスは、Objectクラス、Kernelモジュール、BasicObjectクラスをこの順に親（祖先）に持つことがわかります。
また、aとbは両方ともSampleクラスのインスタンス（オブジェクト）ですが、IDが異なり、違うインスタンスであることがわかります。

ここでは（１）classキーワードでクラスを定義できる（２）newメソッドでインスタンスを生成できる、という2点を理解してください。

## インスタンス変数

インスタンス変数には、@が変数名の先頭についています。
インスタンス変数はそのインスタンスが保持している変数です。

インスタンス変数は「クラス定義の中のメソッド定義（インスタンスメソッド定義）の中」で定義・参照できます。

```ruby
class Sample2
  def inc
    @c = 0 unless @c
    @c += 1
  end
  def dec
    @c = 0 unless @c
    @c -= 1
  end
end

a = Sample2.new
p a.inc
p a.inc
p a.inc
p a.dec
p a.dec
p a.dec
```

クラス定義の中のdef〜endはインスタンスメソッドの定義です。
この例では`inc`と`dec`いう名前のメソッドを定義しています。
メソッドはこのクラスから生成したインスタンスにドット記法で記述し実行します（例えばa.inc、a.decなど）。

- unlessはifの逆で、条件がfalseまたはnilのときに実行する
- インスタンス変数は、何も代入していない段階で参照されるとnilを返す。
incメソッドがはじめて呼ばれたときには@cはnilなので@c=0が実行される
- `@c += 1`は`@c = @c + 1`と同じである。
つまり@cがひとつ増える。
- aはSample2クラスから生成したインスタンス
- a.incが呼ばれるたびに@cが1ずつ増える。
- a.decが呼ばれるたびに@cが1ずつ減る

プログラムを実行すると

```
1
2
3
2
1
0
```

と表示されます。
@cはインスタンスaに属しているので、他のSample2のインスタンスでincメソッドやdecメソッドを呼んでも、aの@cには関係ありません。

（注意）インスタンス変数を**def〜endの外**で記述すると、それは「クラスSample2自身のインスタンス変数」になり、「クラスから生成されたインスタンスのインスタンス変数」にはなりません。
ですから、def〜endの中で記述するようにしてください。

## initialize メソッド

initializeメソッドは特別なメソッドです。
このメソッドはインスタンスが生成される時に自動的に呼ばれ、様々な初期化をするのに用いられます。
このようなメソッドは「コンストラクタ」と呼ばれます。

```ruby
class Sample2
  def initialize
    @c = 0
  end
  def inc
    @c += 1
  end
  def dec
    @c -= 1
  end
end
```

@cの初期化がinitializeメソッドの中で行われ、それぞれのメソッドの役割がより明確になりました。

なお、newメソッドに引数を渡して値を初期化することもできます。
引数はinitializeメソッドに引数として渡されます。

```ruby
class Sample2
  def initialize(c=0)
    @c = c
  end
  def inc
    @c += 1
  end
  def dec
    @c -= 1
  end
end

a = Sample2.new(10)
p a.inc
p a.inc
p a.inc
p a.dec
p a.dec
p a.dec
```

initializeメソッドにcというパラメータが設けられました。
`=0`はデフォルト値といい、メソッドが引数なしで呼ばれた時にデフォルト値が使われます。

```ruby
a = Sample2.new
```

このように引数なしでインスタンスが生成されれば、@cはデフォルト値の0に初期化されます。
さきほどの引数付きのnewメソッドの例を実行すると、次のように表示されます。

```
11
12
13
12
11
10
```

@cが10に初期化されていたことが分かります。

## オブジェクトの例

クラスとインスタンスの全体をまとめて広い意味でオブジェクトということもあります。
小見出しの「オブジェクトの例」はそういう意味で、「クラスの例」と同じです。
何でもオブジェクトにできるのですが、意味のないものを作っても役には立ちません。
さきほどのSampleやSample2は役立たない例ですね。

もう少し役に立ちそうなものを考えてみましょう。
ここではリストを考えてみようと思います。
リストはノードからなる構造で、各ノードには次のノードへのポインタがあります。


```
リスト
ノード1　＝＞　ノード２　＝＞　ノード３　＝＞　ノード４
例えば、
"dog" => "cat" => "sheep" => "elephant" => "lion"
```

リストはデータを保有し、その順番を保持します。

- リストの途中に要素を追加したり削除したりするのが簡単にできる（前後のポインタの付け替えだけですむ）
- 検索は頭からやらなければならないので、大きなリストでは時間がかかり不適当
- 最初の要素はすぐに取り出せるが、最後の要素はリストを辿らなければならないので取り出しに時間がかかる

このことから保存すべきデータ数が多いときはリスト以外の構造を考えるべきです。
しかし、データ数が少ないときには便利なこともあります。
ノードをクラスで定義してみましょう。

```ruby
class Node
  def initialize(d=nil)
    @d = d
    @nxt = nil
  end
  def data
    @d
  end
  def data=(d)
    @d=d
  end
  def nxt
    @nxt
  end
  def nxt=(n)
    @nxt = n
  end
  def insert(n)
    n.nxt = @nxt
    @nxt = n
  end
  def remove
    @nxt = @nxt.nxt
  end
end
```

- @dはそのノードが持つデータを指す変数
- @nxtは次のノードを指す変数。
本当は@nextとしたいところですが、nextがRubyの予約語なのでやめておきました。
- これらのインスタンス変数は、生成されたノード・インスタンス固有のもの
- dataメソッドは保持しているデータを返す
- data=メソッドはデータをセットする
- nxtメソッドは次のノードを返す
- nxt=メソッドは次のノードをセットする
- insertメソッドは次のノードとの間に新たなノードを挿入する
- removeメソッドは次のノードを削除する

メソッド名にアルファベットや数字だけでなく=が使えるのがRubyの特長です。
data=やnxt=は代入のメソッドですが、=がいかにも代入メソッドという感じを出しています。
それに加え、糖衣構文で`n.data = "dog"`と書くと`n.data=("dog)`と直して実行します。
いよいよ代入らしい感じが出てきます。

insertとremoveはリンクの繋ぎ変えのために、ノード自身ではなく、次のノードに対して実行します。

それでは、"dog"と"cat"をリストに繋げてみましょう。

```ruby
start = Node.new
dog = Node.new("dog")
start.insert(dog)
cat = Node.new("cat")
dog.insert(cat)

n = start
while n.nxt
  print n.nxt.data, "\n"
  n = n.nxt
end
```

変数のdog、catと文字列の"dog"、"cat"は別物なので気をつけてください。

while文は、条件が真（falseでもnilでもない）の間while〜endを繰り返すループです。
while文が上手く機能するように、リストの最初のノード（start）にはデータを入れず、次から入れるようにします。
そして、while文ではノードn自身ではなく、次のノードn.nxtがあるかどうか（nilで判断）、n.nxtのデータをとってくるなど、nの次のデータに対してアクションをすることが秘訣です。
実行すると

```
dog
cat
```

と表示され、たしかにリストに"dog"と"cat"が繋げられていました。

今回はここまでにして、次回に更にクラス定義を深めていきたいと思います。

## ラインエディタ

最後におまけとして簡単なラインエディタを紹介します。
（ここは読まなくても良いと思いますーーーおまけです）。

ラインエディタのために、Rubyのreadlineライブラリを使います。
これはGNU Readline によるコマンドライン入力インタフェースを提供するライブラリです。

```ruby
require 'readline'

Start = Node.new
@cur = 0
def get_node(i)
  n = Start
  i.times{n = n.nxt ? n.nxt : n}
  n
end
def all_data
  s = ""
  n = Start
  while n.nxt
    s << n.nxt.data
    n = n.nxt
  end
  s
end
while buf = Readline.readline("> ", false)
  c = buf[0]
  s = buf.slice(2,1000)
  case c
  when "q"
    break
  when "r"
    a = File.readlines(s)
    Start.nxt = nil
    n = Start
    a.each do |s|
      s = s + "\n" unless s[-1] == "\n"
      n.nxt = Node.new(s)
      n = n.nxt
    end
  when "s"
    File.write(s, all_data)
  when "l"
    n = get_node(@cur)
    i = 1
    while n.nxt
      print "#{@cur+i} #{n.nxt.data}"
      n = n.nxt
      i += 1
    end
  when "a"
    a = Node.new("#{s}\n")
    n = get_node(@cur)
    n.insert(a)
    @cur += 1
  when "r"
    n = get_node(@cur)
    n.remove
  when "m"
    @cur = s.to_i
  end
end
```

Startは大文字から始まっています。
大文字から始まるのは定数です。
定数は書き換えができないので、常に最初に代入したオブジェクトを保持します。

- 定数はメソッド内では定義できない
- 定数はクラス定義の中のどこからも（メソッド定義内からも）参照できる
- クラス定義の外で定義された定数はどこからも参照できる

3項演算子` a ? b : c`はaが真ならbを、偽ならcを値として返します。
文字列のsliceメソッドは、`slice(a, b)`で文字列のa番目からb文字を返します。
bが大きすぎれば、文字列の最後までを返します。
case文は、caseの次の式の値とwhenの次の式の値が同じものを上から順に探し、実行します。
Cのswitch文とは違い、どれか一つのwhen節のみを実行します。

動かすには、ノード・クラスの定義の部分とエディタの部分の両方が必要です。

エディタの入力は、最初の1文字がコマンド、次の1文字は無視し、3文字目以下がコマンドの引数になります。

- q： エディタを終了する
- r ファイル名：　ファイルを読み込む。
読み込み前にあったデータはクリアされる
- s ファイル名：　ファイルに書き込む
- l：　現在行以下を表示する
- a 文字列：文字列を現在行の次に挿入する
- d：　現在行の次の行を削除する
- m 行：　現在行を引数の行に移動する。行は0から最終行の間の整数
