---
layout: posts
title: 実数とファイル
description: 実数（浮動小数点数）オブジェクトとFile, Dirオブジェクト、FileUtilsモジュールの解説
date: 2022-9-18 22:00:00 +0900
---
## 実数

実数はそれほど使わないオブジェクトだと思います。
しかし、どんな言語にも実装されているものですし、全然使わないこともないので、ここで取り上げようと思います。
Rubyのドキュメントでは実数を「浮動小数点のクラス」と呼んでいます。
ここでは「実数のクラス」と「浮動小数点（数）のクラス」を同じ意味で使います。

実数のリテラルは小数点のついた数字です。

```ruby
1.2
-3.5
3.4e3
1.0
```

これらはすべて実数です。
最後の1.0は実数オブジェクトであって、整数オブジェクトではないので注意してください。
`3.4e3`は`3.4x10^3`（3.4かける10の3乗）という意味です。
eはexponent（指数）の意味です。

```ruby
print 1.0.class, "\n"
print 1.0, "\n"
print -2.3, "\n"
print 3.4e5, "\n"
print 3.4e-3, "\n"
```

これを実行すると

```
Float
1.0
-2.3
340000.0
0.0034
```

となります。
実数のクラス名は「Float」です。
`.class`メソッドはそのオブジェクトのクラス名を返します。
したがって、1行目は「1.0は実数だ」ということを示しています。

実数は常に近似値だと思ったほうが良いです。
というのは、その数を二進数に直して浮動小数点形式でメモリーに格納するからです。
例えば、十進数の0.1という数を考えてみましょう。

これが二進数の0.abcdef...と表されたとします。
小数点以下の位は、(1/2)、(1/2)\^2、(1/2)\^3、・・・を表します（ちょうど十進小数が(1/10)、(1/10)\^2、(1/10)\^3、・・・となるのと同じ）。
以下、左辺は十進、右辺は二進で表します。
次々2倍していくと

```
0.1 = 0.abcdef...
0.2 = a.bcdefg... => a=0
0.4 = b.cdefgh... => b=0
0.8 = c.defghi...   => c=0
1.6 = d.efghij... => d=1
整数部を取り去る
0.6 = 0.efghij...
1.2 = e.fghijk... => e=1
0.2 = 0.fghijk...
以下2行目からの繰り返しになる
したがって、
0.1 = 0.000110011001100110011.....
```

このように0.1は二進数では無限小数になります。
しかし、実数を収めるメモリサイズは有限なので、そのサイズに収まるように丸められ近似値にされます。
ですから、十進数では誤差無く表せるものがコンピュータの実数（浮動小数点数）では近似値になり、誤差がでることがあります。

```ruby
print 0.2+0.4, "\n"
```

これを実行すると

```
0.6000000000000001
```

と表示されます。
十進数で計算すればぴったり0.6ですが、コンピュータの浮動小数点数では非常に小さい誤差が積み重なってこのような結果になるのです。

このことから

「実数の比較（特に`==`）は正しくないことが圧倒的に多い」

ということです。

```ruby
if 0.2+0.4 == 0.6
  print "equal\n"
else
  print "not equal\n"
end
```

これを実行すると

```
not equal
```

と表示されます。
つまり「0.2+0.4と0.6はイコールでない」ということが起こるのです。

ですから、イコールを用いたいときには何らかの方法で実数を整数に直して計算することが必要になります。
これはRubyに限った話ではありません。
Excelなどでもこのことに注意しないとバグを生み出します。

また、大きさのあまりに違う数字を足すと、小さい方の数字が有効な桁数の外に出て無視されるということも起こります。

```ruby
print 1000000000+0.000000001, "\n"
```

実行すると

```
1000000000.0
```

となり、第2項は第1項に比べあまりに小さすぎて、計算結果に反映されませんでした。

さて、リテラルでは小数点があるのが実数です。

- 1 => 整数（Integerクラスのオブジェクト）
- 1.0 => 実数（Floatクラスのオブジェクト）

同じ名前のメソッドが、異なるオブジェクトでは異なる振る舞いをすることがあるので注意が必要です。

```ruby
print 1 / 2, "\n"
print 1.0 / 2, "\n"
```

実行すると

```
0
0.5
```

となります。
整数の割り算は小数点以下は切り捨てられますが、実数の割り算は小数点以下まで計算されます。

なお、Rubyには、この他に次のような数のオブジェクト（クラス）があります。

- Complex : 複素数
- Rational : 有理数（数を分数として扱うので、浮動小数点数のような誤差がない）

## ファイル

Rubyではファイルもオブジェクトですが、整数や文字列のようなリテラルはありません。
ファイルを扱う方法はたくさんありますが、（私が）よく使うのは次のような方法です。

- `File.read(ファイルのパス名)`  ＝＞ファイル全体を文字列として読み込む。文字列を返す
- `File.readlines(ファイルのパス名)` ＝＞ファイルを行ごとに配列要素にして読み込む。その配列を返す
- `File.write(書き込み先ファイルのパス名, 文字列)` ＝＞ ファイルに文字列を書き出す
- `File.exist?(パス名)` ＝＞パス名で与えられるファイルが通常ファイルとして存在すればtrue、それ以外はfalseを返す

`File`はファイル・オブジェクトのクラス名です。
Rubyではすべてのオブジェクトに文字列に直すメソッドが用意されているので、ファイルに書き込みたい文字列を書き出す`File.write`メソッドだけでも十分です。

例として、Rubyのファイルを読み込んで「`#`から行末まで」を削除し、別ファイルに書き出すプログラムを示します。

```ruby
# This is a comment.
s = File.read("_example/example9.rb") #This is also a comment.
s = s.gsub(/#.*$/, "")
File.write("_example/file2.rb", s)
```

このプログラムの目論見は「Rubyのコメント部分を削除する」ということなのですが、実はそううまくは行きません。
なぜなら

「`#`から行末まで」と「コメント」は同一ではないからです。

例えば上の例にかかげたRubyプログラムではgsubメソッドの正規表現に含まれる`#`から行末まではコメントではありません。
「コメントを削除」したいのであれば、Rubyの字句解析的なことをしなければならず、ことはそう単純ではありません。
ここでは時間の都合からバグ取りは省略します。

File.readとFile.writeの使い方を確認してください。
このように簡単にファイルの読み書きができます。

## ディレクトリ、ファイル・ユーティリティ

ディレクトリ操作として良く使うのは次のような方法です。

- `Dir.children(ディレクトリのパス名)` ＝＞そのディレクトリに含まれるファイル名（`.`と`..`を除く）の配列を返す
- `Dir.glob(パターン文字列)` ＝＞文字列をglobパターンとしてそれに一致するファイル名の配列を返す。globパターンはbashのglobパターンのこと
- `Dir.mkdir(ディレクトリ名)` ＝＞ディレクトリを新規に作成する（後述のファイル・ユーティリティを使う方法も便利）
- `Dir.exist?(ディレクトリのパス名)` ＝＞そのディレクトリが存在すればtrue、なければfalseを返す

ファイル・ユーティリティ「fileutils」というライブラリがあります。
これを使うには

```ruby
require `fileutils`

include FileUtils
```

としておきます。

- `cd(ディレクトリのパス名)` ＝＞カレントディレクトリを変更する
- `chmod(モード, パス名のリスト)` ＝＞リストにあるファイルのパーミッションをモードに変更する
- `cp(ソース, デスティネーション)` ＝＞ソースファイルをデスティネーションファイルにコピーする
- `mkdir_p(ディレクトリのパス名)` ＝＞ディレクトリを作成する。その親ディレクトリがなければ、それもすべて作成する
- `mv(ソース, デスティネーション)` ＝＞ソースファイルをデスティネーションファイルに移動する。ファイル名の変更にも使える
- `remove_entry_secure(パス名)` ＝＞パス名で与えられたファイルまたはディレクトリを削除する。ディレクトリの場合はそれ以下の全てのファイルを削除する
- `rm(パス名)` ＝＞パス名で与えられるファイルを削除する

fileutilsを使わなくてもDIrとFileクラスを使って同じことはできますが、より少ないタイプ量でできるので便利だと思います。
