---
layout: posts
title: 配列
description: 配列とそのメソッド。コマンドラインの引数
date: 2022-9-10 22:00:00 +0900
---
配列は、どのプログラミング言語にもあると思います。
複数の要素を一括して扱うことができるのが配列です。
Rubyの配列はメソッドが充実しているので、プログラムを効率的、機能的に書くのに役立ちます。

## 配列のリテラル

配列を表すには角括弧を用います。

```ruby
a = [1, 2, 3]
```

変数aに配列が代入されています。
右辺は配列を表していて、この配列には1,2,3の3つの要素があり

- 0番目の要素が1
- 1番目の要素が2
- 2番目の要素が3

です。
「〜番目」の「〜」の数字をその要素のインデックスといいます。
インデックスは0から始まることに注意してください。
また、インデックスには負数を用いることもできます。

- -1番目の要素が3
- -2番目の要素が2
- -3番目の要素が1

つまり、負数の場合はおしりから前に戻ってきます。

配列を表すのに角括弧をつかいました。
この配列を表す記法を「リテラル」といいます。
同様にダブル・クォートで囲んだ記法は文字列のリテラルです。
整数のリテラルは、その整数自身を書けばよく、整数オブジェクトの10は単に「10」と書きます。
このようにリテラルとはそのオブジェクトを直接表現する記法のことです。

変数が配列を表すとき、要素を参照するには`[ ]`を用います。

```ruby
a = [1, 2, 3]
print a[1], "\n"
```

printの引数がコンマ区切りで複数渡されています。
このとき、printは各引数に対して画面表示を行います。
ひとつひとつに分けてprintするのと同じ動作になります。

`a[1]`は配列の1番めの要素を表します。
インデックスは0から始まるので`a[1]`は2になります。

`a[5]`のように、配列に要素がないときはnilが返されます。
nilは「何もない」ということを表すオブジェクトだと考えてほぼ間違いありません。

配列の要素に代入するには`[ ]=`を使います。

```ruby
a = [1, 2, 3]
a[1] = 5
print a, "\n"
```

実行してみると

```
[1, 5, 3]
```

と表示されます。
1番目の要素が2から5に変わり、`print a`で配列を表示します。
printは配列をこのように表示してくれるので便利ですね。

`a[6] = 10`のように、何もないところに要素が代入されると、その前の空いていたところにはnilが代入されます。

```
[1, 5, 3, nil, nil, nil, 10]
```

配列はRubyのオブジェクトのひとつです。
ですので、配列はメソッドを持ちます。
実は要素の参照と代入もメソッドです。
`[ ]`と`[ ]=`は糖衣構文で、それぞれメソッド`.[]`と`.[]=`に直して実行されます。

```
a[2] => a.[](2)
a[3] = 5 => a.[]=(3, 5)
```

ひとつめは、「`[]`」がメソッド名で2が引数、ふたつめは「`[]=`」がメソッド名で3と5が引数です。

配列の要素には任意のオブジェクトを代入できます。
配列自身には型がなく、いろいろな種類のオブジェクトがひとつの配列に混在しても構いません。

文字列の配列を表すには`[ ]`とダブルクォートを用いて

```ruby
[ "a", "b", "c" ]
```

と書けますが、%記法というのを使うと少し労力を減らすことができます。

```ruby
abc = %w!a b c!
print abc, "\n"
```

実行すると

```
["a", "b", "c"]
```

と表示されます。
%記法では、「%w」が「文字列の配列を表す」という意味で、「`!`」（区切り）で挟まれた部分の空白で区切られた各文字列が要素になります。
文字列に`!`を入れたいときは、他の文字（非英字）を区切り文字に使います。

```ruby
abc = %w|! !! !!!|
print abc, "\n"
```

実行すると

```
["!", "!!", "!!!"]
```

となります。
括弧類を区切り文字にするときは左括弧と右括弧を組み合わせます。

```ruby
ab = %w(睦月 如月 弥生)
cd = %w[卯月 皐月 水無月]
ef = %w{文月 葉月 長月}
gh = %w<神無月 霜月 師走>
print ab, "\n"
print cd, "\n"
print ef, "\n"
print gh, "\n"
```

実行すると

```
["睦月", "如月", "弥生"]
["卯月", "皐月", "水無月"]
["文月", "葉月", "長月"]
["神無月", "霜月", "師走"]
```

%記法ではダブルクォートを書かなくて良いのが、意外に楽になった感じがします。

1から10までの整数を要素に持つ配列を作るにはRangeオブジェクトを使うと簡単です。
Rangeオブジェクトは整数の範囲を表すオブジェクトです。
例えば`(1..10)`は1から10までの整数を表します。
このRangeオブジェクトには`to_a`というメソッドがあります。
`to_a`はその範囲の数字からなる配列を作ります。

```ruby
a = (1 .. 10).to_a
print a, "\n"
```

実行すると

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

となります。
同様に1から1000までの配列も

```ruby
a = (1..1000).to_a
```

で簡単に作れますね。
`[ ]`リテラルで書くと気が遠くなるでしょう。
C言語では、forループを使って作るのが最も合理的だと思いますが、それでもRubyの短いコードで解決できるのには敵いません。

## 2次元配列

たてよこに広がりを持つデータを配列で表すことができます。
例えばカレンダーを考えてみましょう。

<figure ><img src="/assets/images/calendar.png" style="max-width: 100%;"></figure>

2次元データは縦に1行目、2行目・・・、横に1列目、2列目・・・と数えます（なので、数学では2次元データを「行列」というわけです）。
1行目は7つのマスがあり、それを配列で表すと

```ruby
[nil, nil, nil, nil, nil, 1, 2]
```

nilは「そこに何もない」ということを表します。
2行目以下も同様に配列で表せます。
それを配列で表すと

```ruby
calendar = [
  [nil, nil, nil, nil, nil, 1, 2],
  [3, 4, 5, 6, 7, 8, 9],
  [10, 11, 12, 13, 14, 15, 16],
  [17, 18, 19, 20, 21, 22, 23],
  [24, 25, 26, 27, 28, 29, 30]
]
```

となります。
配列は1行で書いてもよいのですが、長くなってわかりにくいので改行して行ごとに書きました。
カレンダーの3行目は配列で表せます。

```ruby
calendar[2] #=> [10, 11, 12, 13, 14, 15, 16]
```

更に、左から4番めのマスは

```ruby
calendar[2][3] #=> 13
```

となります。
`[ ]`は糖衣構文で、Rubyはメソッドに直してから実行するのでした。

```
calendar[2] => calendar.[](2)
```

`[]`がメソッド名で、2はメソッドの引数。このメソッドは[10, 11, 12, 13, 14, 15, 16]を返す。
返されたものが配列なので、再び`[]`メソッドが使え、

```
calendar[2][3] => (calendar.[](2)).[](3) => [10, 11, 12, 13, 14, 15, 16].[](3) => 13
```

となります。
以上から、上から3行目、左から4列めの要素は`calendat[2][3]`と表せます。
数字が1だけずれるのは、1から数え始めるか0から数え始めるかの違いから起こります。
どちらも0から始めることに直せば、

上から2行目、左から3列めの要素は`calendat[2][3]`

ということになります。
一般に

上からm行目、左からn列めの要素は`calendat[m][n]`

です。

このように、たてよこに広がりのあるデータは配列を二重に使うことによって表せます。
この二重の配列を2次元配列といいます。

注意したいのは、2次元配列という新たなオブジェクトが作られたわけではなく、もともとあった（1次元）配列とそのメソッドを繰り返し使っただけだということです。
ですから、3回繰り返せば3次元配列、4回繰り返せば4次元配列・・・・というように拡張できます。

## 配列のメソッド

配列には多くの有用なメソッドがありますが、ここではその一部を紹介します。
まず、eachとeach\_indexはよく使われるメソッドです。
eachは配列要素を順に取り出しブロックを実行します。

```ruby
[1,2,3,4,5].each do |i|
  print i, "\n"
end
```

- 最初の要素1をパラメータiに代入してブロックを実行＝＞1が表示される
- 次の要素2をパラメータiに代入してブロックを実行＝＞2が表示される
- 以下、順に5までパラメータiに代入して実行

実行結果は次のようになります

```
1
2
3
4
5
```

each\_indexは要素のインデックス（0からはじめて何番目か）をパラメータにします。

```ruby
a = ["青", "黃", "赤"]
a.each_index do |i|
  print i
  print " => "
  print a[i]
  print "\n"
end
```

実行してみます。

```
0 => 青
1 => 黃
2 => 赤
```

この2つに似たメソッドにeach\_with\_indexがあり、これは要素とインデックスの2つをパラメータに渡します。

```
["青", "黃", "赤"].each_with_index do |x, i|
  print i
  print " => "
  print x
  print "\n"
end
```

出力結果はeach\_indexの例と同じになります。

Rubyでは、eachイテレータを使うことが多いです。
for文やwhile文もRubyにはあるのですが、イテレータのほうが読みやすく分かりやすくなることが多いです。

## 配列の変更と複製

配列は変更可能なオブジェクトです。
それは、`[ ]=`で要素を代入できることからも分かります。
その他に配列自身を変更するメソッドには次のようなものがあります。

- `<<` ＝＞ 配列の最後に要素を加え、できた配列を値として返す。
糖衣構文によって、演算子のように記述できる。
例えば、`[1,2] << 3`によって、配列が`[1, 2, 3]`に変更され、その配列がメソッドの値として返る。
メソッドで書き直すと`[1,2].<<(3)`となる。
- `append`または`push`。
この2つは同じ動作のメソッドで、引数（複数可）を配列の後ろに加える。
`[1, 2].append(3, 4) => [1, 2, 3, 4]`。
引数は配列`[3, 4]`にしても同じ結果になる
- `pop` ＝＞ 配列の最後の要素を取り除き、その取り除いたオブジェクトを値として返す。
引数が正の整数であれば、その数だけ取り除く
- `clear` ＝＞ 配列の要素をすべて取り去り、空の配列にする。
このとき、配列の要素だったオブジェクトは残る。
配列がそれらのオブジェクトを要素として指さなくなったということ
- `delete` ＝＞ 引数と同じ要素をすべて取り除く
- `delete_at` ＝＞ 引数はインデックスを表す。そのインデックスの要素を取り除く

この他にも配列自身を変更するメソッドがありますが、詳細はRubyのドキュメントを参照してください。
なお、自身を変更するメソッドを「破壊的」メソッドといいます。

clear、delete、delete\_atなどで説明したように、配列から削除することはそのオブジェクトを消滅させることではありません。
配列は変数に似ていて、各オブジェクトを「指している」だけです。

この点はCの配列とは異なります。
Cの配列は型があり、その型の「配列の要素数分のメモリが確保されます。
そして配列のメモリの中に値が書き込まれていきます。
したがって、配列のある要素を変更すると、以前の値は消えてしまいます。
Rubyの場合は指しているオブジェクトが変わるだけで以前のオブジェクトは消滅しません。

```ruby
a = "abc"
b = "def"
c = [a, b]
print c, "\n"
c[0] = "ABC"
print a, "\n"
print c, "\n"
```

これを実行すると次のようになります。

```
["abc", "def"]
abc
["ABC", "def"]
```

配列cの0番目の要素は文字列オブジェクト"abc"から"ABC"に変わりましたが、元のオブジェクト"abc"は残っていて、変数aを表示した時に`abc`が表示されています。

配列はオブジェクトを指しているだけなので、配列を複製（コピー）して新たな同じ内容の配列をオブジェクトとして作成するとき、各オブジェクトは複製されないことに注意してください。
複製は`dup`メソッドまたは`clone`メソッドで行います。
この2つは細かい点で振る舞いが違いますが、ここではその説明は省略します。

<figure ><img src="/assets/images/dup.png" style="max-width: 100%;"></figure>

このようなコピーをシャロー・コピー（shallow copy）といいます。

シャロー・コピーをすると同じオブジェクトを異なる配列から参照しているので、一方でオブジェクトを変更（破壊的メソッドを使う）と他方の配列にも影響します。
そのためバグを生じやすいので注意しなければなりません。
これを避けるには

- 破壊的メソッドを使わない。
例えば`a[0]=="abc"`のとき、`a[0].replace("ABC")`は破壊的メソッドで文字列オブジェクトが変更される。
それに対して`a[0]="ABC"`は新しい文字列"ABC"を生成して0番目の要素を取りかえるだけで元のオブジェクトは変更されずに残る
- オブジェクトの複製も行う。
eachメソッドを使って各オブジェクトの複製を作るなどの方法があります。
このとき元の配列と複製された配列は違うオブジェクトを指すので、破壊的メソッドを使っても他の配列に影響はありません
- オブジェクトを変更禁止にしておく。
freezeメソッドを使うとオブジェクトは変更禁止になります。
すべての破壊的メソッドは効かなくなります（エラーになる）

のようなことが考えられます。
一番良いのは安易に配列の複製をしないことだと思います。

## ARGV

コマンドラインからRubyプログラムを実行する時に引数を渡すことができます。
引数は配列`ARGV`に渡されます。
大文字から始まる識別子は定数を表します。
`ARGV`は定数なのでこれに代入することはできません。

```ruby
ARGV.each do |x|
  print x, "\n"
end
```

これを`example6.rb`に保存して、実行してみましょう。

```
$ ruby example6.rb Hello world
Hello
world
$
```

引数は半角の空白で区切られてARGVに格納されます。
eachメソッドで引数をひとつずつ取り出して表示しています。

引数が何個あるかを調べたいときがあります。
そのときはsizeメソッドを使います。
