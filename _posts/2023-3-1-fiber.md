---
layout: posts
title: Fiber
description: Fiber
category: Documentation
date: 2023-3-1 21:00:00 +0900
---

Fiberは「ノンプリエンプティブな軽量スレッド」とRubyのマニュアルに記載されています。

- ノンプリエンプティブ（non preemptive）とは、マルチタスクの切り替えをプログラム自身にまかせること
- プリエンプティブ（preemptive）とは、マルチタスクの切り替えをOSが行うこと

preemptiveは金融の用語のようです。
「先買いの、先買権のある」と辞書にありますが（ジーニアス英和辞典）、株式の売却時に優先的に買い取る権利を含む契約で、敵対勢力に株式を渡さないための方策だそうです。
このことについては、私は門外漢なので、正確な情報ではないことをお断りしておきます。
IT用語においては、「プリエンプティブ」はCPU時間を割り当てるときにOSが優先的にCPU時間を買取ってタスクに割り当てる、ということから使われるようになったのではないでしょうか。

さて、Fiberを使う場合、メインのプログラムとFiberのブロックの2つのタスクが動きます。
そして、プログラム中のresumeやyieldというメソッドがタスクの切り替えをします。
したがって、切り替えは完全にプログラムによってコントロールされており、その点でいつ切り替わるかはOS次第というプロセスとは異なります。
また、ここでいうタスクはRubyのThreadとは異なるので注意してください。

- [簡単なプログラム例](#簡単なプログラム例)
  - [ファイバーの定義](#ファイバーの定義)
  - [簡単なプログラム例](#簡単なプログラム例-1)
- [ファイバーの使いどころ](#ファイバーの使いどころ)
  - [イテレータ](#イテレータ)
  - [パイプ](#パイプ)
- [ファイバーとメソッド](#ファイバーとメソッド)

# 簡単なプログラム例

## ファイバーの定義

ファイバーを定義するには、`Fiber.new`を使い、ファイバー自体はそのブロックに記述します。

```ruby
fiber = Fiber.new do
  "abc".each_char do |c|
    print "#{c}\n"
    Fiber.yield
  end
  nil
end
```

このブロックはメインプログラムの中で呼ばれる`fiber.resume`メソッドによって実行されます。

- 最初に`fiber.resume`が呼ばれたとき、ブロックの最初から`Fiber.yeild`までが実行される
- `Fiber.yield`の実行により、ブロックは一旦実行が止まり、メインルーチンの`fiber.resume`の次からに実行が移る
- 次に`fiber.resume`が呼ばれたときは、ブロックの`Fiber.yield`から実行され、再び`Fiber.yield`に達するか、ブロックの最後に達するまでそれが続く
その後は実行はメインルーチンの`fiber.resume`の次に移る
- ブロックの最後まで達したファイバーは`field.resume`が呼ばれても実行できない。これはエラーになる

## 簡単なプログラム例

次の例は、メインとファイバーのブロックで交互にprint文を実行するメソッドです。

```ruby
def example1
  fiber = Fiber.new do
    "abc".each_char do |c|
      print "#{c}\n"
      Fiber.yield
    end
    nil
  end

  101.upto(103) do |j|
    fiber.resume
    print "#{j}\n"
  end
end

# main

example1
```

このプログラムの実行順を図にしました。

![Fiberの実行順]({{ "/assets/images/fiber.png" | relative_url }})

実行結果はつぎのようになります。

```
$ ruby _example/example39.rb
a
101
b
102
c
103
$ 
```

ポイントは、`Fiber.yield`と`fiber.resume`で切り替わるところです。

# ファイバーの使いどころ

ファイバーはどのようなプログラムに適しているのでしょうか？
ファイバーはコルーチンと呼ばれることもありますが、ウィキペディアの[コルーチン](https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%AB%E3%83%BC%E3%83%81%E3%83%B3)では、

> サブルーチンと異なり、状態管理を意識せずに行えるため、協調的処理、イテレータ、無限リスト、パイプなど、継続状況を持つプログラムが容易に記述できる。

と書かれています。

ここでは、このうちイテレータとパイプについて考えてみたいと思います。
なお、ここでの記述については、誤りを含んでいるかもしれませんので、ご注意ください。
また、誤りにお気づきの方はコメントでご指摘いただければありがたいです。

## イテレータ

イテレータというと、Rubyのeachメソッドを思い浮かべるのではないでしょうか。
eachメソッドは、そのオブジェクトの要素を取り出してブロック・パラメータに代入し、繰り返しブロックを実行します。
このような繰り返し処理を「イテレータ」といいます。
eachメソッドの方式は「内部イテレータ」といいます。

これに対して「外部イテレータ」というのがあります。Enumeratorクラスのnextメソッドはその例です。
nextメソッドは呼ばれるたびに「次のデータ」を返します。

```ruby
def example2
  a = [1,2,3].to_enum
  p a.next #=> 1
  p a.next #=> 2
  p a.next #=> 3
end

example2
```

このプログラムでは配列`[1,2,3]`を`to_enum`メソッドでEnumeratorオブジェクトに変換しています。
Enumeratorオブジェクトのnextメソッドは呼ばれるたびに、1,2,3と順にその要素を返していきます。
ひとつのメソッド「next」が呼ばれるたびに異なる要素を返すので、これもイテレータと呼ばれるのです。
より正確には「外部イテレータ」です。

外部イテレータはFiberで簡単に実装できます。

```ruby
def example3
  fiber = Fiber.new do
    [1,2,3].each do |i|
      Fiber.yield(i)
    end
  end

  p fiber.resume
  p fiber.resume
  p fiber.resume
end

example3
```

Fiber.yieldに引数をつけると、その引数の値が対応するfiber.resumeの値になります。
これによって、ファイバーから外部にデータを渡すことができます。

この例では、ファイバー外部でresumeを呼ぶたびにファイバー内部のイテレータが繰り返し処理をするので、順に要素が返されます。

なお、[Rubyのドキュメント](https://docs.ruby-lang.org/ja/3.1/class/Fiber.html)に

> Enumerator（の外部イテレータ）は Fiber を用いて実装されています。

と書かれています。

## パイプ

パイプというのは、Bashなどのシェルプログラムで2つのプロセスをつなぎ、片方の出力を他方の入力につなげる機能です。
例えば

- cat: ファイルを読み込み、標準出力に書き出す
- wc: 文字数、単語数、行数などを計算して書き出す

をパイプ「`|`」で結びつけると、

```
$ cat example3.rb | wc
     39      59     455
```

となり、ファイルexample3.rbは

- 行数が39
- 単語数が59（単語は空白や改行で区切られる文字列）
- 文字数が455

であることがわかります。
このとき

- catによってexample3.rbの内容が標準出力に送られ
- その出力はパイプ「`|`」によって次のコマンドの標準入力に結び付けられ
- それはwcによって行数、単語数、文字数として標準出力に出力される

ということになります。

一般にあるプロセスの出力をバッファに保存し、それを別のプロセスの入力につなげる問題を「生産者ー消費者問題」といいます。
並行動作するプロセスでこれを行う場合、セマフォを使って実現します。
セマフォは一般に短いプログラムで、セマフォの実行中は他のタスクに切り替わらないことが保証されています。

ファイバーを使う場合は、タスクが切り替えのタイミングを決められるのでセマフォは不要で、プログラムも簡単になります。
また、消費者側をメインにし生産者側をファイバーにする「消費者起動方式」が理解しやすいです。

catとwcに相当するプログラムをFiberで作ってみましょう。
ただし、単純化するためwc部分は行数のみをカウントすることにします。

```ruby
def example4 filename
  fiber = Fiber.new do
    File.open(filename) do |file|
      while (s = file.gets)
        Fiber.yield(s)
      end
    end
    nil
  end

  nline = 0
  while fiber.resume
    nline +=1
  end
  print "#{nline}\n"
end

example4("_example/example39.rb")
```

ファイバー側はファイルをオープン後、一行入力してはyieldします。
EOFになると`file.gets`はnilを返すのでwhileループが終了します。
ですから、最後に`fiber.resume`で呼ばれたときは、whileループを脱出するので`Fiber.yield`は実行されません。
そのときには`Fiber.new`のブロックの値（ブロックの最後に評価された値）が`fiber.resume`の値として返されます。
すなわち、nilが返ります。

メインルーチンは`fiber.resume`の値をチェックして真（この場合は文字列が返っている）ならば`nline`をカウントアップします。
最後にnilが返ってきてwhileループを抜け、nlineの値をプリントします。

# ファイバーとメソッド

ファイバーはイテレータやパイプなどを分かりやすく表現することができるのですが、同様のことはインスタンス変数とメソッドで実現することができます。
そのため、あまりファイバーは使われないのが実情ではないでしょうか。

しかし、最後の例のようなファイルをオープンするケースをメソッドで実装する場合、オープンとクローズは別メソッドで行うのが多いです。
つまり、オープン、一行読込、クローズの3つのメソッドを用いることになります。
Fiberは、その中でオープン、クローズも行えるので一つで済み、実装が簡単です。

ファイバーは他の言語ではコルーチンと呼ばれることもあります。
例えば、Luaではコルーチンと呼んでいます。
ネットでもファイバーよりもコルーチンで検索するほうが多くの情報にヒットします。
