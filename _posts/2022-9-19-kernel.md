---
layout: posts
title: Kernelモジュール
description: Kernelモジュールの提供するメソッドの解説
date: 2022-9-19 22:00:00 +0900
---
Kernelモジュールのメソッドはどこでも使うことができます。
そのメソッドの中には便利で有用なものが多いです。

## バックティックとsystemメソッド

バックティック（\`）で囲まれた文字列をbashコマンドとして実行し、その標準出力を文字列として返します。

```ruby
print `pwd`
```

「pwd」はUNIXコマンドでカレントディレクトリの絶対パスを返します。
もし、カレントディレクトリが`/home/user1`ならば、このプログラムによってそれが画面に表示されます。
なお、バックティックのコマンドで得られる文字列には改行が最後に含まれます。

同じことを％記法で書くことができます。

```ruby
print %x{pwd}
```

バックティックと%xでは同じ結果になります。

コマンドの実行だけが必要で、その標準出力が不要な場合はsystemコマンドを使います。
systemでは、実行したコマンドが正常終了した場合true、それ以外の終了ステータスではfalseを、コマンドが実行できなかったときはnilを返します。

```ruby
system "cp file1 file2"
```

これにより、file1をfile2にコピーします。

これらのメソッドによって、数多くの実行コマンドをRubyプログラムで使うことができます。
蓄積されたソフトウェアを使えることでプログラムの手間を減らすことが可能です。

## exit

Rubyプログラムを終了します。
引数を与えるとそれを終了ステータスとして親プロセスに通知することができます。

## p, pp, printf, sprintf

pとppメソッドは人間に読みやすい形にして引数の式を出力します。
これらはデバッグでよく用いられます。

```ruby
p [1,2,3,4] #-> [1, 2, 3, 4]
pp [1,2,3,4] #-> [1, 2, 3, 4]
```

例では両方が同じ出力ですが、引数によってはppの方が適切な改行を入れたり、より読みやすくフォーマットしてくれます。
これらは、ユーザが作ったオブジェクトに対して使うと効果的です。
デバッグ用途なので、完成したプログラムの出力用途に使うことはありません。

printfはCのprintfと同様のフォーマットで出力をします。
sprintfは同様のフォーマットで文字列を作成します。
フォーマットについては[Wikipedia](https://ja.wikipedia.org/wiki/Printf)が参考になります。

```ruby
printf "%04d\n", 123
printf "%04d\n", 12
printf "%4d\n", 12
```

これを実行すると

```
0123
0012
  12
```

と表示されます。

- %とdで整数を埋め込むことを意味する
- %の次の0は表示幅に対して数字の桁数が少ない時に頭を0で埋める意味
- その次の4は表示幅（4桁の幅）

詳しくは、Wikipediaなどのprintfのフォーマットを見てください。
上記のように主に小数点を揃えたりするときに使います。

## $stderr

これはメソッドではなく、特殊変数です。
標準エラー出力を表します。
メッセージを標準出力に出さず、標準エラー出力に出す時に使います。

標準出力と標準エラー出力はデフォルトで画面出力になっているので、区別のつかない人もいるかもしれません。
エラーメッセージや警告メッセージを標準出力に出すと、そのプログラムの（エラーメッセージでない）本来の出力と混ざってしまいます。
特に標準出力をファイルにリダイレクトするとエラーメッセージもファイルに書き込まれてしまい、台無しになってしまいます。
これを避けるにはメッセージを標準エラー出力に出すようにします。
標準出力のリダイレクトは標準エラー出力には影響しないので、リダイレクト後も標準エラー出力は画面出力となります。

```ruby
$stderr.print "エラーですよ\n"
```

## rand

乱数を発生させます。
いろいろな使い方ができますが、例えば1から20までの数字をでたらめに並べたいときには次のようなプログラムが考えられます。

```ruby
seq = (1..20).map{|i| [i, rand]}.sort{|a,b| a[1]<=>b[1]}.map{|a| a[0]}
print seq, "\n"
#=> [10, 14, 15, 18, 13, 17, 19, 7, 9, 4, 8, 20, 6, 5, 11, 16, 12, 1, 2, 3]
```

実行ごとに乱数は変わるので、数字の並び方も実行ごとに異なります。

- 1から20のRangeオブジェクトにもmapメソッドがある。
1から20の数字に対してブロックを実行した結果を要素とした配列を返す
- 最初のmapにより、数字と乱数がペアになった配列20個の配列ができあがる
- sortメソッドで乱数の大きさで小さい順にソート
- mapメソッドで整数の部分だけを取り出す

これで1から20までを、その時の乱数の大きさ順に並べ替えた配列が得られます。

## raise

例外を発生させます。
デバッグ時に良く使います。
メッセージを引数として与えることができます。

```ruby
abc = 10
if abc.class != Integer
  raise "abcが整数ではない!\n"
end
```

このプログラムでは変数abcが整数なのでif文は成り立たず、例外は発生しません。
もし、abcを文字列など、整数以外のものに変更すると例外が発生し

```
example11.rb:3:in `<main>': abcが整数ではない! (RuntimeError)
```

エラーメッセージが出力されます。
デバッグ時に、期待された動作ではない場所にraiseを埋め込んでおきます。

もちろん、完成したバージョンの中にraiseを埋め込んでおくことも可能です。
実行時に、プログラム時に想定されないことが起こるのは良くあることです。
そのとき、立ち直りが不可な状態であれば、例外を発生して終了するしかないでしょう。

## require

ライブラリを取り込む時に使います。
Rubyにはビルトイン以外にも豊富なライブラリがあります。
それらを使う時にrequireで取り込みます。
プログラムの最初でrequireすることが多いです。

## eval

引数の文字列をRubyのコマンドとして実行します。
何でもできてしまうので、外部から入手した文字列に対してevalすることは極めて危険です。
それだけは絶対にしないでください。

```ruby
eval 'print "evalしたよ\n"' #=>「evalしたよ」が表示される
```

引数は実行時に組み立てることになると思います。
（そうでなく、プログラム時に知ることのできる文字列なら、evalを使う必要はないから）。
その組みたての過程でバグが入る可能性がありますから、慎重の上にも慎重を重ねて使ってください。

## test

ファイルのテストをするメソッドです。
とくに、2つのファイルの関係をテストするのが役に立ちそうです。

```ruby
test ">", file1, file2
```

このテストではfile1の方がfile2よりも最終更新日時が新しければtrueとなります。
この他にもファイルの情報を得るコマンドがあります。
