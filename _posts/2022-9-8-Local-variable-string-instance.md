---
layout: posts
title: ローカル変数、文字列、インスタンス
description: インスタンスを理解する。そのためにローカル変数と文字列も説明。
date: 2022-9-8 01:00:00 +0900
---
今回の目標はインスタンスです。
インスタンスを説明するために、ローカル変数と文字列オブジェクトを事前に扱います。

## ローカル変数

変数にはローカル変数、インスタンス変数、クラス変数がありますが、今回はローカル変数のみ説明します。

ローカル変数は（１）英小文字またはアンダースコア（`_`）で始まり（２）英文字、数字、アンダースコアが続きます。
例えば`abc`、`_d55`などは変数を表すことができます。
これらはメソッド名にもなりうるので、それが変数なのかメソッド名なのかはプログラムの中で判断します。

ローカル変数はその変数に対する代入文がはじめて現れた時に、代入と同時に定義されます。
一度定義されると、そこからその変数が宣言されたブロック、メソッド定義、またはクラス/モジュール定義（次回以降に説明）の終りまで有効です。
この有効範囲をスコープといいます。
メソッド定義の外側で定義されたローカル変数はメソッド定義の中では参照できません。

```ruby
abc = 10
print abc
print "\n"

def abcdefg
  print "Hello world.\n"
  print abc
  print "\n"
end

abcdefg
```
このプログラム`example5.rb`として保存し、実行するとエラーになります。

```
$ ruby example5.rb
10
Hello world.
example5.rb:7:in `abcdefg': undefined local variable or method `abc' for main:Object (NameError)

  print abc
        ^^^
        from example5.rb:11:in `<main>'
$
```

プログラムを順を追って見ていきましょう

- ローカル変数`abc`に10を代入する
- `print abc`で10が画面に表示される＝＞実行画面の最初の10
- メソッド`abcdefg`を定義する。
メソッドは
  - Hello world.を画面に表示し
  - ローカル変数abcを表示し、改行を表示する
- メソッド定義では実行はしないので、エラーにはならない。
- メソッド`abcdefg`を呼び出し、実行する
  - Hello world.を画面表示する＝＞実行画面２行目のHello world.
  - ローカル変数`abc`の値を画面表示しようとするが、`abc`が未定義なのでエラーになる＝＞3行目以降のエラーメッセージ
- エラーになったのは1行目で定義したローカル変数`abc`はメソッド内部では参照できないから。
つまり、メソッド内部はスコープではないからです。

`abc`をメソッドの外に移せば、スコープになるのでエラーにならずに10が表示されます。

```ruby
abc = 10
print abc
print "\n"

def abcdefg
  print "Hello world.\n"
end

abcdefg
print abc
print "\n"
```

実行すると

```
10
Hello world.
10
```

また、メソッドの中でローカル変数を定義すると、その変数はメソッドの中だけで有効で、外はスコープ外になります。

## 文字列と変数

変数には文字列を代入することもできます。

```ruby
a = "Hello world.\n"
b = a
a = "Good by.\n"

print b
```

ちょっとややこしいプログラムなんですが、これを実行すると画面には何が現れるでしょうか

- 1 Hello world. が表示される
- 2 Good by. が表示される

実行してみましょう

```
Hello world.
```

1が正解でした。
プログラムを順に見ていきます。

- 変数`a`に文字列"Hello world.\n"が代入された＝＞aは文字列"Hello world.\n"を指している
- 変数`b`に変数`a`の指している文字列を代入した＝＞bは文字列"Hello world.\n"を指している
- 変数`a`に文字列"Good by.\n"が代入された＝＞aは文字列"Goodby.\n"を指している

最後の代入は変数'b'には関係ありませんから、bは相変わらず文字列"Hello world.\n"を指しています。

Rubyの文字列は可変です。
これはRubyの特徴で、良い場合と困る場合があります。
可変であるためにバグを生みやすいということは言えると思います。

例えば、文字列は`[]=`を使って文字を書き換えできます。

```ruby
a = "free\n"
a[0] = "t"
print a
```

このプログラムを実行すると`tree`が表示されます。

- 変数`a`に文字列"free\n"が代入された
- aの指している文字列の0番目の文字（文字を数えるとき最初の文字は0番目です）を"t"に変える＝＞"free\n"が"tree\n"になる
- aの指す文字列"tree\n"を画面に表示

この`[]=`というのは配列のn番目の要素を代入するのに似ています。
文字列は文字の配列だと考えれば自然な演算です。

さて、次のプログラムを実行すると何が表示されるでしょうか

```ruby
a = "free\n"
b = a
a[0] = "t"

print b
```

- 1 freeが表示される
- 2 treeが表示される

実行すると、"tree"が表示されます。
2が正解です。
なぜでしょうか？

- 変数`a`に文字列"free\n"が代入された
- 変数`b`に変数`a`の指している文字列を代入した＝＞bは文字列"free.\n"を指している＝＞aとbは同じ文字列を指していることに注意
- aの指している文字列の0番目の文字を"t"に変える＝＞"free\n"が"tree\n"になる
＝＞bもaと同じ文字列を指しているので、bは"tree\n"を指している
- bの指す文字列"tree\n"を画面に表示

何となくわかったでしょうか？
正しく理解するためには、インスタンスを理解することが必要です。

## インスタンス

Rubyでは、文字列も数字もプログラムの対象になるものはすべてオブジェクトです。
オブジェクトはその中に状態を保ち続けることができる変数とメソッドを持ったもので、そのオブジェクトがどういう変数やメソッドを持っているかを定義しているものをクラスといいます。
クラスに基づいて、メモリ上にオブジェクトを実現したものをインスタンスといいます。
ひとつのクラスに対して通常は複数のインスタンスが可能です。

なお、「オブジェクト」と「インスタンス」という言葉はそれぞれのプログラミング言語により、使い分けられています。
Rubyの場合は両者は同じと考えて差し支えありません。
ですが、「インスタンス」というときは、「クラス」をメモリ上に実体化したというニュアンスが強くなります。
また、オブジェクトは「オブジェクト指向」という概念的な意味で使うこともあります。

例えば文字列のクラスはStringといいます。
"Hello world\n"というダブルクォートで囲まれた文字列がプログラム中に現れると、RubyはStringクラスのインスタンスを作ります。
インスタンスはメモリ上に作られ、その文字列がHello world\nであるという情報や、String固有のメソッドがあるという情報を保持します。

```ruby
a = "Hello world.\n"
```

RubyはまずHello world\nという文字列のインスタンスをメモリ上に作成し、その場所を変数`a`に代入します。
変数aはそのインスタンスを指しているだけです。

```ruby
a = "Hello world.\n"
a = "Good by.\n"
```

- Hello world.\nという文字列インスタンスをメモリ上に作成し、aがそのインスタンスを指すようにする
- Good by.\nという文字列インスタンスをメモリ上に作成し、aがそのインスタンスを指すようにする。
このとき、はじめにaが指していたHello world.\nインスタンスはどこからも指されなくなる＝＞不用になるので近いうちに消滅する（ガベージ・コレクション）

```ruby
a = "Hello world.\n"
b = "Hello world.\n"
```

この場合、Hello world.\nという文字列インスタンスが2つ作られます。
aとbが指しているインスタンスは別のインスタンスです（文字列としては同じですが）。
インスタンスにはオブジェクトidという番号が振られ、区別できるようになっています。
オブジェクトidはobject_idメソッドで知ることができます。

```ruby
print "Hello world.\n".object_id
print "\n"
print "Hello world.\n".object_id
print "\n"
```

これを実行すると

```
60
80
```

のようになります。
（あなたが実行するとき60や80とは違う数字になるかもしれません）。
同じ文字列だが、インスタンスとしては別だということがidの違いからわかります。

もう理解できたとは思いますが、最後に1問。

```ruby
a = "free\n"
b = "free\n"
a[0] = "t"
print b
```

このとき、

- 1 freeが表示される
- 2 treeが表示される

のどちらですか？

答えは1です。
aとbは別のインスタンスを指しているので、aの指している文字列が変わってもbの指している文字列は変わっていません。

## 「同じ」ということ

```ruby
a = "free\n"
b = "free\n"
```

このとき、aとb（正しくはaの指している文字列とbの指している文字列）は同じでしょうか？
これはちょっとむずかしい問題です。

- インスタンスとしては異なる
- 文字列の内容としては同じ

そこで、どちらを基準に考えているかによって2種類の「同じ」を判断する計算が必要になります。

- ` a == b` => aとbが同じ文字列ならtrue、違う文字列ならばfalse
- `a.eql?(b)` => aとbが同じ文字列ならtrue、違う文字列ならばfalse
- `a.equal?(b)` => aとbが同じインスタンスならtrue、違うインスタンスならば（文字列として同じであっても）false

`eql?`と`equal?`は文字列のメソッドです。
実は`==`も文字列のメソッドで、`a == b`は`a.==(b)`というメソッドだとして評価されます。
Rubyではメソッド名にアルファベットや数字だけでなく`==`や`?`のような記号も使えるのが面白いところで、長所です。
この`==`メソッドと`eql?`は、ほぼ同じです。
詳しくは[Rubyのドキュメント](https://docs.ruby-lang.org/ja/3.0/class/String.html#I_--3D--3D)を見てください。

## 糖衣構文

このように`==`という論理演算子はRubyではメソッド`.==( )`に直されて評価されるのはなぜでしょうか（`==`のようなメソッドと別形式が用意されているときその別形式を糖衣構文またはシンタックス・シュガーといいます）。
それは「同じ」ということの意味がオブジェクトごとに違うからです。
また、実装上も`==`をオブジェクトごとに定義するのが楽です。
（むしろ、一般的な`==`演算子を作り、どのオブジェクトにも通用するようにするのは事実上無理です）

同じことは`+`という演算子についてもいえます。
実はこれも糖衣構文で

```
10 + 5 => 10.+(5)
```

このように整数のメソッドに直して評価されます（メソッド名が`+`）。
整数の場合は算術的な加算としてメソッドが定義されていますが、文字列では連結としてメソッドが定義されています。

```
"abc" + "def" => "abc.+("def") => "abcdef"
```

他のオブジェクトでも`+`メソッドを定義することができます。
加算がオブジェクトごとに意味づけられるというのは面白い考えです。

## 整数のインスタンス

さて、整数の場合は文字列と違って可変ではありません。
このとき同じ整数を表すインスタンスを複数作るのは非効率です。
そこで整数の場合はあるひとつの整数を表すインスタンスは一つしか存在しません。

```ruby
print 100.object_id
print "\n"
print 100.object_id
print "\n"
```

これを実行すると

```
201
201
```

となります。
1行目の整数100と3行目の整数100は同じオブジェクトidなので、インスタンスとしても同じとわかります。

## Rubyの変数とCの変数の違い

Rubyの変数はオブジェクトを指しているだけで、変数自体に型はありません。

Cの場合は変数に型がかならず付けられます。

```c
int n;

n = 10;
```

変数nはint型（整数型）として定義されます。
このとき、Cではnに対して整数を格納できるサイズのメモリを割り当てます。
`n=10;`の代入文で、そのメモリに10が格納されます。

このようにCでは型とメモリが変数に結びついています。

```c
int a, b;

a = b = 100;
```

このとき、aとbはそれぞれメモリを割り当てられて、100はそれぞれのメモリに代入されます。
このあと、aのメモリを変更してもbの値は変わりません。

Rubyの場合は

```ruby
a = b = "free\n"

a[0] = "t"
```

aとbは同じオブジェクトを指しているので、aがオブジェクトの内容を変更すると、bも同じものを参照しているので内容が変わります。

C言語習得者がRubyを習うと、このあたりで躓くことが多いと思います。
Rubyの変数はCのポインタのようなものだと思うとわかりやすいと思います。

さて、最後に「オブジェクト」と「インスタンス」についてもう一度。
今回は「インスタンス」を多用しましたが、Rubyのドキュメントでは「オブジェクト」の方が多く用いられています。
今後もそのときの文脈でどちらかを選択して使いますが、意味は同じだと考えてください。
